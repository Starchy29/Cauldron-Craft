#pragma kernel Update

struct TileInfo {
    int floorType; // 0: ground, 1: wall, 2: pit
    int highlightType;
    int terrainController;
    int capturer; // 0: not a capture point, -1: no team, 1: left team, 2: right team, 3: both teams
};

// NONE: 0
#define AREA_VISUAL 1
#define HIGHLIGHT 2
#define OPTION 3
#define HOVERED 4
#define SELECTED 5

float4 team1Color;
float4 team2Color;

int pixPerTile;
int2 tileDims;
float t;
#define PI 3.14159

int2 cursorTile;
RWStructuredBuffer<TileInfo> _TileData;
RWTexture2D<float4> _Texture;

TileInfo getTile(int x, int y) {
    if(x < 0 || y < 0 || x >= tileDims.x || y >= tileDims.y) {
        TileInfo junk;
        junk.terrainController = -1;
        junk.highlightType = -1;
        return junk;
    }

    return _TileData[x + tileDims.x * y];
}

[numthreads(8,8,1)]
void Update(uint3 id : SV_DispatchThreadID) {
    int2 tile = id.xy / pixPerTile;
    float2 tileUV = float2(id.xy - tile * pixPerTile) / pixPerTile;
    TileInfo tileData = getTile(tile.x, tile.y);
    
    float4 color = float4(0, 0, 0, 0);

    TileInfo leftTile = getTile(tile.x - 1, tile.y);
    TileInfo rightTile = getTile(tile.x + 1, tile.y);
    TileInfo aboveTile = getTile(tile.x, tile.y + 1);
    TileInfo belowTile = getTile(tile.x, tile.y - 1);

    // outline with controller
    if(tileData.terrainController != 0) {
        // terrain controller
        float lineThickness = 0.05;
        if(leftTile.terrainController != tileData.terrainController && tileUV.x < lineThickness
            || rightTile.terrainController != tileData.terrainController && tileUV.x > 1.0 - lineThickness
            || belowTile.terrainController != tileData.terrainController && tileUV.y < lineThickness
            || aboveTile.terrainController != tileData.terrainController && tileUV.y > 1.0 - lineThickness
        ) {
            color = tileData.terrainController == 1 ? team1Color : team2Color;
        }
    }
    else if(tileData.capturer != 0) {
        // capture point controller
        float lineThickness = 0.25;
        if(leftTile.capturer != tileData.capturer && tileUV.x < lineThickness
            || rightTile.capturer != tileData.capturer && tileUV.x > 1.0 - lineThickness
            || belowTile.capturer != tileData.capturer && tileUV.y < lineThickness
            || aboveTile.capturer != tileData.capturer && tileUV.y > 1.0 - lineThickness
        ) {
            switch (tileData.capturer) {
            case -1:
                color = float4(1, 1, 1, 1);
                break;
            case 1:
                color = team1Color;
                break;
            case 2:
                color = team2Color;
                break;
            case 3:
                color = (team1Color + team2Color) / 2;
                break;
            }

            float distFromEdge = 1;
            if(leftTile.capturer != tileData.capturer) {
                distFromEdge = min(distFromEdge, tileUV.x);
            }
            if(rightTile.capturer != tileData.capturer) {
                distFromEdge = min(distFromEdge, 1 - tileUV.x);
            }
            if(belowTile.capturer != tileData.capturer) {
                distFromEdge = min(distFromEdge, tileUV.y);
            }
            if(aboveTile.capturer != tileData.capturer) {
                distFromEdge = min(distFromEdge, 1 - tileUV.y);
            }

            float root = (1 - distFromEdge / lineThickness);
            color.a = 0.7 * root * root;
        }
    }

    // fill in highlight
    switch(tileData.highlightType) {
    case HIGHLIGHT:
        color = float4(0.9, 0.9, 0.7, 0.5);
        break;
    case OPTION:
        color = float4(0, 0.8, 0.8, 0.5 + 0.1 * sin(t * 4 * PI));
        break;
    case HOVERED:
        color = float4(0, 0.2, 0.8, 0.5 + 0.2 * sin(t * 8 * PI));
        break;
    case SELECTED:
        color = float4(0.5, 0.9, 0.5, 0.5 + 0.2 * sin(t * 2 * PI));
        break;
    case AREA_VISUAL:
        //color = float4(0.9, 0.9, 0.7, 0.1);
        float diagonalLength = tileUV.x + tileUV.y;
        float diagonalFreq = 0.25;
        float stripeWidth = 0.03;
        float distToStripe = min(diagonalLength % diagonalFreq, .25 - diagonalLength % diagonalFreq);
        if(distToStripe < stripeWidth) {
            float centerValue = 1 - distToStripe / stripeWidth;
            color = float4(0.9, 0.9, 0.7, 0.5 * min(1, centerValue + 0.5));
        }

        float lineThickness = 0.05;
        if(leftTile.highlightType != HIGHLIGHT && leftTile.highlightType != AREA_VISUAL && tileUV.x < lineThickness
            || rightTile.highlightType != HIGHLIGHT && rightTile.highlightType != AREA_VISUAL && tileUV.x > 1.0 - lineThickness
            || belowTile.highlightType != HIGHLIGHT && belowTile.highlightType != AREA_VISUAL && tileUV.y < lineThickness
            || aboveTile.highlightType != HIGHLIGHT && aboveTile.highlightType != AREA_VISUAL && tileUV.y > 1.0 - lineThickness
        ) {
            color = float4(0.9, 0.9, 0.7, 0.5);
        }
        break;
    }

    if(tileData.floorType == 0) {
        // add grid lines
        bool isCursor = tile.x == cursorTile.x && tile.y == cursorTile.y;
        float lineThickness = isCursor ? 0.05 : 0.015;
        float outlineValue = isCursor ? 0.7 : 0.1;
        if(tileUV.x < lineThickness || tileUV.x > 1 - lineThickness || tileUV.y < lineThickness || tileUV.y > 1 - lineThickness) {
            float edgeSpot = tileUV.x < lineThickness || tileUV.x > 1 - lineThickness ? tileUV.y : tileUV.x; // 0 - 1 along the edge
            int edgeSegments = 7;
            int edgeIndex = edgeSpot * edgeSegments;
            if(edgeIndex % 2 == 0) {
                color = color.a > 0 ? color + float4(outlineValue, outlineValue, outlineValue, 0) : float4(1, 1, 1, outlineValue);
            }
        }
    }

    _Texture[id.xy] = color;
}
